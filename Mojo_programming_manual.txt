## Using the Mojo compiler
With the Mojo SDK, you can run a Mojo program from a terminal just like you can with Python

(In ubuntu os)
$ cat hello.mojo
def main():
    print('hello world')
    for x in range(9,0,-3):
        print(x)

$ mojo hello.mojo

## Basic systems programming extensions
# let and var declarations
Inside a def in Mojo, you may assign a value to a name and it implicitly creates a function scope  variable just like in Python
This provides a very dynamic and low-ceremony way to write code, but it is a challenge for two reasons:

1. Systems programmers often want to declare that a value is immutable for type-safety and performance.
2. They may want to get an error if they mistype a variable name in an assignment.

To support this, Mojo provides scoped runtime value declarations: let is immutable, and var is mutable

Note that let and var are completely optional when in a def function, but they're requried for all variables
in an fn function
Also beware tht when using Mojo in a REPL environment, top-level variables are treated like variables in a def,
so they allow implicit value type declarations (they do not require var or let declarations, nor type declarations). This matches the Python REPL behavior

# struct types
Mojo is based on MLIR and LLVM, which offer a cutting-edge compiler and code generation system used in many programming languages
An important feature of modern systems programming languages is the ability to build high-level and safe abstractions on top of these complex, 
low-level operations without any performance loss. In Mojo, this is provided by the struct type

A struct in Mojo is similar to Python class
But differences of struct and class is:
-Python classes are dynamic : they allow for dynamic dispatch, monkey-patching (or â€œswizzlingâ€), and dynamically binding instance properties at runtime
-Mojo structs are static : they are bound at compile-time (you cannot add methods at runtime). Structs allow you to trade flexibility for performance while being safe and easy to use.

ex. 
struct MyPair:
    var first: Int
    var second: Int

    # We use 'fn' instead of 'def' here - we'll explain that soon
    fn __init__(inout self, first: Int, second: Int):
        self.first = first
        self.second = second

    fn __lt__(self, rhs: MyPair) -> Bool:
        return self.first < rhs.first or
              (self.first == rhs.first and
               self.second < rhs.second)
